---
title: "Lab 2: Working with Data, Part 2"
author: "Joel Ledford"
date: "Winter 2019"
output:
  html_document:
    theme: spacelab
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

## Load the tidyverse
```{r message=FALSE, warning=FALSE}
library("tidyverse")
```

## Learning Goals
*At the end of this exercise, you will be able to:*    
1. Import .csv files as data frames.  
2. Use summary functions to explore the contents of a data frame.  
3. Use the functions of dplyr (filter, select, arrange, mutate) to organize and sort data frames.  

## Data Frames
For the remainder of the course, we will work exclusively with data frames. Recall that data frames allow us to store multiple types of data. In the first session, you were shown how to build data frames using the `data.frame()` command. However, most scientists make their data available in some form as supplementary material associated with a publication. As data scientists, we can capitalize on this by importing data directly into R.

## Loading Data into Data Frames
R allows us to import a wide variety of data types. The most common type of file is a .csv file which stands for comma separated values. Spreadsheets are often developed in Excel then saved as .csv files for use in R. There are packages that allow you to open excel files and many other formats but .csv is the most common.

To open a .csv file, be sure that you are in the correct working directory.
```{r echo=T, results='hide'}
getwd()
```

It is best to store the data as a new object. My only caveat is that unless you really need to, don't create an object called 'data' or 'dat'. Other bad choices include: x, y, z, input, etc.

Also, while many people specify a discrete path in the read command it only works on their computer because it is local. This is generally not good practice. Instead include the .csv file in a folder called `data` within your working directory.

Here we open a .csv file with data on fish scales. Since we are using the tidyverse, we open the file using read_csv. 
```{r message=FALSE, warning=FALSE}
fish <- readr::read_csv("data/Gaeta_etal_CLC_data.csv")
```

## Summary functions
Once data have been uploaded, you may want to get an idea of its contents and dimensions. This may seem self-evident for small files but this is a big help for large data files.
```{r}
nrow(fish) #the number of rows
ncol(fish) #the number of columns
dim(fish) #total dimensions
colnames(fish) #column names
```

There are many other useful summary functions, all of which work a bit differently. I didn't try to make the joke about fish heads and tails on purpose, but here it is anyway.
```{r}
head(fish)
tail(fish)
```

`summary()` and `str()` are classic functions used by many R programmers. `glimpse()` is part of the tidyverse.
```{r}
summary(fish)
str(fish)
glimpse(fish)
```

## Practice
Load the data mammal life histories and place it into a new object.
```{r message=FALSE, warning=FALSE}
mammals <- readr::read_csv("data/Mammal_lifehistories_v2.csv")
```

1. Provide the dimensions of the data frame.
```{r}
dim(mammals)
```

2. Check the column names in the data frame. 
```{r}
names(mammals)
```

3. Use str() to show the structure of the data frame and its individual columns; compare this to glimpse(). 
```{r}
str(mammals)
```

```{r}
glimpse(mammals)
```

4. Print out the first few rows of the data using the function head().  
```{r}
head(mammals)
```

## [Tidyverse](https://www.tidyverse.org/)
The tidyverse is a collection of packages that make workflows in R easier. The packages operate differently than base R commands so if you look at older code you will see that there are many different ways of accomplishing the same task. Although not universal, the tidyverse has been adopted by many (most) users. In our class, we embrace the tidyverse philosophy and thus will be doing things the tidy way.  

![*Data Science Workflow in the Tidyverse.*](tidyverse1.png)

## Dplyr: filter()
A core package in the tidyverse is dplyr. This package allows you to transform your data in many different ways including filtering, subsetting, and reordering. This helps keep your data cleaner, easier to work with, and easier for other people to understand.  

The first command that we will learn is `filter()`. Filter allows you to subset observations in a data frame by their values. You should still have the fish data loaded, but if not then please re-load.  
```{r}
fish <- read_csv("data/Gaeta_etal_CLC_data.csv")
```

Let's say that we are interested only in the fish that occur in the lake labeled AL. We can use `filter()` to extract these observations to build a new data frame focused on our question.
```{r}
filter(fish, lakeid=="AL")
```

Similarly, if we are only interested in fish with a length greater than or equal to 350 we can use `filter()` to do this work.
```{r}
filter(fish, length>=350)
```

Filtering allows all of the expected operators; i.e. >, >=, <, <=, != (not equal), and == (equal).  It also allows us to extract multiple values simultaneously.
```{r}
filter(fish, lakeid=="AL" & length>350)
```

When we use the '&' above, we are asking for a specific filter: provide only those data for which both lakeid=AL AND length is greater than 350. Filter will use other operators, but always keep in mind that you are asking for something very specific.  

Rules: & is “and”, | is “or”, and ! is “not”.

Notice that the code below generates a data frame larger than the one above because it includes non AL lakes.
```{r}
filter(fish, lakeid=="AL" | length<350)
```

If you want to filter multiple values in the same variable you can use the `%in%` operator. This is a useful way to simplify your code.
```{r}
filter(fish, length %in% c(167, 175))
```

But, be careful when reading the code like a human; why does this not work? How would you correct the problem?
```{r}
filter(fish, length==167 & length==175)
```

## Dplyr: select()
Select allows you to build a new data frame by selecting your variable(s) of interest. Our fish data only has six variables, but this should give you some ideas especially when you have a large data frame.

We are only interested in lakeid and scalelength.
```{r}
select(fish, lakeid, scalelength)
```

The - operator is useful in select. It allows us to select everything except the specified variables.
```{r}
select(fish, -fish_id, -annnumber, -length, -radii_length_mm)
```

For very large data frames with lots of variables, `select()` utilizes lots of different operators to make things easier. Let's say we are only interested in the variables that deal with length.
```{r}
select(fish, contains("length"))
```

Some additional options to select columns based on a specific criteria include:  
1. ends_with() = Select columns that end with a character string  
2. contains() = Select columns that contain a character string  
3. matches() = Select columns that match a regular expression  
4. one_of() = Select columns names that are from a group of names  

## Dplyr: Can we combine filter() and select()?
Absolutely. This is one of the strengths of the tidyverse, it uses the same grammar to specify commands.
```{r}
fish2 <- select(fish, lakeid, scalelength)
filter(fish2, lakeid=="AL")
```

## Dplyr: Pipes %>% 
The code above works fine but there is a more efficient way. We need to learn pipes `%>%`. Pipes allow you to feed the output from one function to the input of another function. We are going to use pipes from here on to keep things cleaner. (command+shift+m)
```{r}
fish%>%
  select(lakeid, scalelength)%>%
  filter(lakeid=="AL")
```

## Dplyr: arrange()
The `arrange()` command is a bit like a sort command in excel.
```{r}
fish %>% 
  arrange(scalelength)
```

It can be very helpful in combination with the other functions.
```{r}
fish %>% 
  select(lakeid, length, fish_id, scalelength) %>% 
  filter(lakeid=="AL") %>% 
  arrange(fish_id)
```

## Dplyr: mutate()
The `mutate()` command will allow you to generate new columns. These new columns are powerful because they can be populated by the output of functions.
```{r}
fish %>%
  mutate(length_scalelength_ratio=length/scalelength)
```

## Practice
We are going to practice our dplyr skills using examples from a package called gapminder. This dataset includes information about economics, population, and life expectancy from countries all over the world.
```{r eval=FALSE, include=FALSE}
install.packages("gapminder") #installs the package
library("gapminder") #loads the library
```

```{r}
data(package="gapminder") #contents of the library
```

```{r}
gapminder <- gapminder::gapminder # loads the data into a new object
```

1. What are the dimensions of the gapminder data frame? Use some of the summary functions that you have learned to explore its contents.
```{r}
dim(gapminder)
names(gapminder)
```

```{r}
glimpse(gapminder)
```

```{r}
head(gapminder)
```

2. Build a new data frame that is restricted to countries in Africa.

```{r}
filter(gapminder, continent=="Africa")
```

3. For which countries do we have data from the 1950's?

```{r}
filter(gapminder, year<=1959 & year>=1950)
```

4. Filter the gapminder data for years in the 1950's but only in Africa. Restrict the data frame to country, continent, and pop. Sort the data by pop. Do this using pipes.

```{r}
gapminder %>% 
  filter(year %in% c(1952, 1957)) %>% 
  filter(continent=="Africa") %>% 
  select(country, continent, pop) %>% 
  arrange(pop)
```

5. You are a data scientist working on a program in Africa. You need to build a data frame that shows the percent population increase for African countries only, between 1952-2007. In your final data frame, show the country, population in 1952, population in 2007, raw growth, and percent growth.

```{r}
pop1952 <- gapminder %>%
  filter(year==1952) %>% 
  filter(continent=="Africa") %>% 
  select(country, year, pop)
pop1952
```

```{r}
pop2007 <- gapminder %>%
  filter(year==2007) %>% 
  filter(continent=="Africa") %>% 
  select(country, year, pop)
pop2007
```

```{r}
pop_growth_raw <- gapminder %>% 
  filter(continent=="Africa") %>% 
  filter(year==1952) %>% 
  select(country) %>% 
  mutate(pop_1952=pop1952$pop) %>% 
  mutate(pop_2007=pop2007$pop) %>% 
  mutate(pop_growth_raw=pop2007$pop-pop1952$pop) %>% 
  arrange(pop_growth_raw)
pop_growth_raw
```

```{r}
pop_growth_percent <- pop_growth_raw %>% 
  mutate(pop_growth_percent=(pop_growth_raw/pop_2007)*100) %>% 
  arrange(pop_growth_percent)
pop_growth_percent
```

## Wrap-up
Please review the learning goals and be sure to use the code here as a reference when completing the homework.

See you next time!